# 풀이 과정
### 1. 생각
- 최장 부분 수열을 구하는 문제이다.
- 정석적인 최장 부분 수열을 구하는 방법은 다음과 같다.
```
1. "각각의 수로 끝나는 부분 최장 수열의 길이는 몇인가?"라는 문제로 작게 쪼갠다.
ex) 주어진 배열이 "1 2 3 2 4"라면 
1로 끝나는 최장 부분 수열은?
2로 끝나는 최장 부분 수열은? ...
2. 그 중에서 가장 큰 숫자를 구한다. (dp)
```
- 그러나 개수가 100만개이기 때문에 정석적인 최장 부분 수열을 구하는 방법인 N^2로는 풀 수 없다.
- 또한 가장 긴 부분 수열을 반환해야하므로 값도 저장해야한다.
- 따라서 풀이 과정은 다음과 같다.

### 2. 사용된 변수
- 최장 부분 수열을 저장하는 배열: dp
- 최장 부분 수열의 각 인덱스를 저장하는 배열: dpIdx
- 자신으로 끝나는 최장 부분 수열에서 나의 바로 앞 원소를 저장하는 배열: prev
- prev는 N^2 시간 문제를 해결하기 위해 필요한 것으로, index만으로 최장 수열을 역추적하기 위해 필요하다.

### 3. 풀이 과정
시간 문제를 해결한 것은 이분 탐색이 핵심적이다.<br>
각 원소는 dp를 이분 탐색하며 현재의 원소가 들어갈 자리를 찾는다. <br>
prev로 이어주면 prev만 역추적하더라도 각 원소로 끝나는 최장 부분 수열을 구할 수 있다.
```
//디버깅 과정
[10, 20, 10, 30, 20, 50]이 주어졌다고 가정
1. dp: [10], dpIdx: [0], prev[0] = -1
2. dp: [10, 20] dpIdx: [0, 1] prev[1] = 0
3. dp: [10, 20] dpIdx: [2, 1] prev[2] = -1
4. dp: [10, 20, 30] dpIdx: [2, 1, 3] prev[3] = 1
5. dp: [10, 20, 30] dpIdx: [2, 4, 3] prev[4] = 2
6. dp: [10, 20, 30, 50] dpIdx: [2, 4, 3, 5] prev[5] = 3

결국 가장 긴 최장 부분 수열의 길이는 dp의 길이가 되며, 50으로 끝나는 배열이 가장 길다.
50의 prev를 역추적하면 최장 부분 수열이 나온다.
prev[5] = 3 => prev[3] => 1 => prev[1] => 0 => prev[1] = -1 //-1이면 역추적 종료
```



- 문제 링크: https://www.acmicpc.net/problem/14003
